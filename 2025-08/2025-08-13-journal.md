---
title: Prioritizing learning
Date: 2025-08-13
Author: Joel Anderson
description: Today I've got some new SupaBase and PostgreSQL work to do so I get to prioritize some learning and understanding around that.
---

## Start of Day:

### What are my goals today?
Learn more about functions in Supabase, and fully qualifying names in db functions


### What are my challenges today?
I've got a few hats to juggle today, so trying to minimize the time it takes to context switch or just making sure to be conscious of the cost of task switching and being strategic about it.


## End of Day

### Have I reached my goals today?
100% crushed it today. heaps of learning about PostgreSQL and SupaBase, and Juggled all my task switching flawlessly. Just being conscious of it makes such a difference

### What have I learned today?
I learned about setting attibutes when creating funcitions like Immutable, stable, and volatite (volatile is the default if none is given) immutable is good for things like password hashes (when given the same input) the output is always the same. Stable is good for the life of the function ie. when a query is made and it needs to call the function several times, it will cache the result the first time, so the function doesn't need to be called for the reset of the query. and volatile basical means it can change so always keep calling it.

Two of the main focuses was using SECURITY INVOKER on views as these default to having the creators privileges which is SECURITY DEFINER and bypasses RLS. And the second this was either qualifying all schema names inline or SET search_path = '' or SET search_path = '<schema name>, <default schema name (public)>'

I also learned about COST which seems like a funny magic thing inside of PostgreSQL that optimizing queries.

I also really internalized the value of `squase and merge` when merging into main. Now that I am doing it when working people who are not me, it makes things way more readable.

## Journal

### SupaBase functions
learning about how to setup a function in SupaBase. Pretty intersting you basically name the function tell it what type of data it will return kind of like TypeScript would do but with more SQLish syntax. and then you specifiy to programming language. ie. PL/pspgsql (`plpspgsql`) for PostgreSQL's built it procedural programming language, but you can also use `plpython3u` or `c`. then you set the functions security control using `SECURITY DEFINER` for the db creators privilages this is kind of like running a command with sudo it gives full access and bypasses RLS policies in SupaBase, and the other option is `SECURITY INVOKER` which just means current user and their privlages based on the RLS policies.

Security invoker only works if there are RLS policies. otherwise the security logic has to be built straight into the functions/queries or has to be filtered from the serverside code. RLS is the way to go!

#### Volatility
I also learned about some other optional categories like VOLATILITY, STRICT, and COST. VOLATILITY is pretty straightforward with values like `VOLATILE` (default if volatility is not set), `IMMUTABLE` means with the same inputs the output will always be the same, and last `STABLE` this one means inside each call of the function the values will be the same. ie. `current_user_id()` is a function we have created. if we have a query that uses this function say to get all to do's for the current user if there is more than one todo current_user_id() would get called every single to do. if you add stable to the current_user_id() function, When that query comes through is calls the function on the first to do and caches the result so for each following to do the cached result is used.

#### Cost
This one was interesting as you can decide what functions cost on compute and give the info to postgreSQL and PostgreSQL will do it's magic and run operations in the most performant way possible. feels a bit like magic but I'm not going to question it.

#### Strictness
And the last one I learned about was strictness which basically tells the function how to handle null inputs. You can tell it not to run the function and save compute if the input is null with `RETURN NULL ON NULL INPUT` or to process the null values with `CALL ON NULL INPUT`

Next I learned about `AS $$` which is amazing! basically reduces the crazy quoting syntax that can happen in SQL. it's kind of like a string literal in javascript if you wrap your function in `AS $$ <function> $$` you save yourself a lot of double quote non-sense.

#### Schema Qualification
This was kind of the main thing I learned today because SupaBase gave me some security advisory warnings that pointed me to fixing this problem. I learned that by explicitly qualifying schema in your migrations and RLS Policies, and functions that you can remove an attack vector for SQL injection. basically when running a query the db searches for the users path and then the public path if not qualified. so the users path could inject something that runs a SECURITY DEFINER bypass function that sets them as a superadmin or something like that. hopefully you get the idea. but if you put public.users that is the only allowed path. or if you have `SET search_path = ''` then users will return nothing so you have to qualify all schema names. but SET search_path does offer the alternative to inline by creating a list of acceptable paths. ie. `SET search_path = 'public'`

#### AS
I also got more clarity around AS in SQL syntax it's kind of like `=` in JavaScript or most programming languages. it's how you assign value to something. ie `name AS n` in queries or `CREATE FUNCTION dogs AS $$ <function> $$` for functions, or `CREATE VIEW dogs AS SELECT names FROM public.dogs` for views (this is not a good use of views :laughing:)



### Squash and merge :head_exploding:
Wow I knew about squash and merge, but didn't really understand it's purpose but now that I am doing tons of tiny commits, then when you go to merge those 50 commits into main that no one understands I see the value of being able to squash it down into a single commit in the commit history as `feat: the entire feature this branch accomplished` instead of including ones like "chore: ran prettier linting"


